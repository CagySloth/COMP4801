#!/usr/bin/env python3
"""
read_reads_tsv.py

Reader for two TSV formats generated by the phasing simulators:

1) Sparse format:
   Columns: read_id, hap_truth, start, positions, alleles
   - positions: comma-separated 0-based variant indices for the read
   - alleles: string over {0,1,-} aligned to positions
   - Reads can cover (contiguous) segments; the parser accepts arbitrary positions.

2) Dense format:
   Columns: read_id, hap_truth, alleles
   - alleles: string over {0,1,-} of length N
   - Every read covers all N variants.

The script:
- Auto-detects mode from header (or accept --mode).
- Loads reads into memory.
- Prints a concise summary.
- Optionally writes a normalized NPZ:
  - For dense:
      keys: mode="dense", read_ids (U), hap_truth (int32), alleles (int8, shape [R,N], -1=missing)
  - For sparse:
      keys: mode="sparse", read_ids (U), hap_truth (int32),
            read_ptr (int32, len R+1), positions (int32, len M), alleles (int8, len M),
            num_variants (int) [inferred or provided]
- Optionally converts sparse -> dense and saves with --to-dense-npz.

Dependencies: numpy

Examples:
  python read_reads_tsv.py -i demo.reads.sparse.tsv
  python read_reads_tsv.py -i simple.reads.tsv
  python read_reads_tsv.py -i demo.reads.sparse.tsv --to-npz demo_sparse.npz
  python read_reads_tsv.py -i demo.reads.sparse.tsv --to-dense-npz demo_dense.npz --num-variants 1000
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from typing import List, Tuple, Optional

import numpy as np


@dataclass
class DenseReads:
    read_ids: List[str]
    hap_truth: np.ndarray  # (R,) int32
    alleles: np.ndarray    # (R, N) int8; -1=missing


@dataclass
class SparseReads:
    read_ids: List[str]
    hap_truth: np.ndarray  # (R,) int32
    read_ptr: np.ndarray   # (R+1,) int32; CSR-style pointer into positions/alleles
    positions: np.ndarray  # (M,) int32
    alleles: np.ndarray    # (M,) int8; -1=missing
    num_variants: int      # inferred or user-specified


def sniff_mode(path: str) -> str:
    """
    Inspect the header/first line to guess format.
    Returns "dense" or "sparse".
    """
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            s = line.strip()
            if not s:
                continue
            if s.startswith("#"):
                cols = s.lstrip("#").strip().split("\t")
                cols = [c.strip().lower() for c in cols]
                if "positions" in cols or "start" in cols:
                    return "sparse"
                if "alleles" in cols and "positions" not in cols and "start" not in cols:
                    # Likely dense header
                    return "dense"
                continue
            # Non-comment, data line: infer by column count
            parts = s.split("\t")
            if len(parts) == 5:
                return "sparse"
            if len(parts) == 3:
                return "dense"
            # Fallthrough; keep scanning in case the first data line is malformed
    raise ValueError("Unable to detect mode from file. Please pass --mode dense|sparse.")


def _allele_string_to_int8_array(allele_str: str) -> np.ndarray:
    """
    Convert a string over {0,1,-} to int8 array with -1 for missing.
    """
    # Fast path when characters are guaranteed valid: map via dict
    mapping = {"0": 0, "1": 1, "-": -1}
    try:
        return np.array([mapping[ch] for ch in allele_str], dtype=np.int8)
    except KeyError as e:
        raise ValueError(f"Invalid allele character '{e.args[0]}' in '{allele_str}'. Expected only 0,1,-.") from None


def parse_dense_tsv(path: str) -> DenseReads:
    """
    Parse dense TSV: read_id, hap_truth, alleles_string
    """
    read_ids: List[str] = []
    hap_truth_list: List[int] = []
    rows: List[np.ndarray] = []
    n_variants: Optional[int] = None

    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip() or line.startswith("#"):
                continue
            parts = line.rstrip("\n").split("\t")
            if len(parts) != 3:
                raise ValueError(f"Expected 3 columns in dense mode, got {len(parts)}: {line.strip()}")
            rid, hap_str, alleles_str = parts[0], parts[1], parts[2].strip()
            if not alleles_str:
                raise ValueError("Alleles string is empty; dense format expects a fixed-length allele string per read.")
            a = _allele_string_to_int8_array(alleles_str)
            if n_variants is None:
                n_variants = a.shape[0]
            elif a.shape[0] != n_variants:
                raise ValueError(f"Inconsistent allele string length: expected {n_variants}, got {a.shape[0]} for read_id {rid}")
            read_ids.append(rid)
            hap_truth_list.append(int(hap_str))
            rows.append(a)

    if n_variants is None:
        # No rows parsed
        return DenseReads(read_ids=[], hap_truth=np.empty(0, dtype=np.int32), alleles=np.empty((0, 0), dtype=np.int8))

    hap_truth = np.asarray(hap_truth_list, dtype=np.int32)
    alleles = np.stack(rows, axis=0) if rows else np.empty((0, n_variants), dtype=np.int8)
    return DenseReads(read_ids=read_ids, hap_truth=hap_truth, alleles=alleles)


def parse_sparse_tsv(path: str, num_variants: Optional[int] = None) -> SparseReads:
    """
    Parse sparse TSV: read_id, hap_truth, start, positions, alleles
    - positions: comma-separated list of indices (can be empty for zero-length read).
    - alleles: string over {0,1,-}, same length as positions.
    - num_variants: if None, inferred as max(positions)+1 (0 if no positions).
    """
    read_ids: List[str] = []
    hap_truth_list: List[int] = []

    read_ptr = [0]
    pos_acc: List[int] = []
    allele_acc: List[int] = []

    max_pos = -1

    with open(path, "r", encoding="utf-8") as f:
        for ln, line in enumerate(f, start=1):
            if not line.strip() or line.startswith("#"):
                continue
            parts = line.rstrip("\n").split("\t")
            if len(parts) != 5:
                raise ValueError(f"Line {ln}: expected 5 columns in sparse mode, got {len(parts)}: {line.strip()}")
            rid, hap_str, start_str, pos_str, alleles_str = parts
            rid = rid.strip()
            hap = int(hap_str.strip())
            pos_str = pos_str.strip()
            alleles_str = alleles_str.strip()

            if pos_str == "":
                positions = []
            else:
                try:
                    positions = [int(x) for x in pos_str.split(",") if x != ""]
                except ValueError:
                    raise ValueError(f"Line {ln}: positions must be comma-separated integers, got: {pos_str}")

            a = _allele_string_to_int8_array(alleles_str) if alleles_str else np.empty(0, dtype=np.int8)

            if len(positions) != int(a.shape[0]):
                raise ValueError(
                    f"Line {ln}: positions length ({len(positions)}) != alleles length ({a.shape[0]})."
                )

            # Optional consistency check with 'start' if contiguous; not required.
            # We do not enforce contiguity; positions can be arbitrary.

            read_ids.append(rid)
            hap_truth_list.append(hap)

            pos_acc.extend(positions)
            allele_acc.extend(a.tolist())
            read_ptr.append(len(pos_acc))

            if positions:
                max_pos = max(max_pos, max(positions))

    hap_truth = np.asarray(hap_truth_list, dtype=np.int32)
    read_ptr_arr = np.asarray(read_ptr, dtype=np.int32)
    positions_arr = np.asarray(pos_acc, dtype=np.int32) if pos_acc else np.empty(0, dtype=np.int32)
    alleles_arr = np.asarray(allele_acc, dtype=np.int8) if allele_acc else np.empty(0, dtype=np.int8)

    if num_variants is None:
        inferred_nv = (max_pos + 1) if max_pos >= 0 else 0
    else:
        inferred_nv = int(num_variants)

    return SparseReads(
        read_ids=read_ids,
        hap_truth=hap_truth,
        read_ptr=read_ptr_arr,
        positions=positions_arr,
        alleles=alleles_arr,
        num_variants=inferred_nv,
    )


def sparse_to_dense(sr: SparseReads, fill_value: int = -1) -> DenseReads:
    """
    Convert SparseReads to DenseReads with shape (R, N). Fills missing with fill_value (default -1).
    """
    R = len(sr.read_ids)
    N = sr.num_variants
    if N <= 0:
        return DenseReads(read_ids=sr.read_ids, hap_truth=sr.hap_truth.copy(), alleles=np.empty((R, 0), dtype=np.int8))

    mat = np.full((R, N), fill_value, dtype=np.int8)
    # Fill observed alleles
    for i in range(R):
        start_idx = sr.read_ptr[i]
        end_idx = sr.read_ptr[i + 1]
        if end_idx > start_idx:
            pos = sr.positions[start_idx:end_idx]
            val = sr.alleles[start_idx:end_idx]
            mat[i, pos] = val
    return DenseReads(read_ids=sr.read_ids, hap_truth=sr.hap_truth.copy(), alleles=mat)


def summarize_dense(dr: DenseReads) -> str:
    R = len(dr.read_ids)
    N = dr.alleles.shape[1] if dr.alleles.ndim == 2 else 0
    if R == 0 or N == 0:
        return f"Mode: dense\nReads: {R}\nVariants: {N}\n"
    miss = int(np.sum(dr.alleles < 0))
    total = int(dr.alleles.size)
    miss_frac = miss / total if total else 0.0
    # Hap truth distribution
    unique, counts = np.unique(dr.hap_truth, return_counts=True) if dr.hap_truth.size > 0 else ([], [])
    dist = ", ".join(f"{int(u)}:{int(c)}" for u, c in zip(unique, counts))
    return (
        "Mode: dense\n"
        f"Reads: {R}\n"
        f"Variants: {N}\n"
        f"Missing calls: {miss} ({miss_frac:.3%})\n"
        f"Hap truth distribution: {dist}\n"
    )


def summarize_sparse(sr: SparseReads) -> str:
    R = len(sr.read_ids)
    M = int(sr.alleles.size)
    N = sr.num_variants
    miss = int(np.sum(sr.alleles < 0))
    # Average observed positions per read
    lens = sr.read_ptr[1:] - sr.read_ptr[:-1]
    avg_len = float(np.mean(lens)) if lens.size > 0 else 0.0
    # Coverage if N known (>0)
    cov_summary = ""
    if N > 0 and sr.positions.size > 0:
        coverage = np.zeros(N, dtype=np.int64)
        np.add.at(coverage, sr.positions, 1)
        cov_summary = f"\nCoverage per variant (min/mean/max): {int(coverage.min())}/{float(coverage.mean()):.2f}/{int(coverage.max())}"
    # Hap truth distribution
    unique, counts = np.unique(sr.hap_truth, return_counts=True) if sr.hap_truth.size > 0 else ([], [])
    dist = ", ".join(f"{int(u)}:{int(c)}" for u, c in zip(unique, counts))

    return (
        "Mode: sparse\n"
        f"Reads: {R}\n"
        f"Num variants (inferred): {N}\n"
        f"Total observed allele entries (M): {M}\n"
        f"Avg observed positions per read: {avg_len:.2f}\n"
        f"Missing calls: {miss} ({(miss / M if M else 0.0):.3%})\n"
        f"Hap truth distribution: {dist}"
        f"{cov_summary}\n"
    )


def save_dense_npz(dr: DenseReads, path: str) -> None:
    np.savez_compressed(
        path,
        mode=np.array("dense"),
        read_ids=np.array(dr.read_ids, dtype="<U"),
        hap_truth=dr.hap_truth,
        alleles=dr.alleles,
    )


def save_sparse_npz(sr: SparseReads, path: str) -> None:
    np.savez_compressed(
        path,
        mode=np.array("sparse"),
        read_ids=np.array(sr.read_ids, dtype="<U"),
        hap_truth=sr.hap_truth,
        read_ptr=sr.read_ptr,
        positions=sr.positions,
        alleles=sr.alleles,
        num_variants=np.array(sr.num_variants, dtype=np.int32),
    )


def main():
    ap = argparse.ArgumentParser(description="Read phasing read TSVs (dense or sparse) and summarize/optionally save NPZ.")
    ap.add_argument("-i", "--input", required=True, help="Path to reads TSV file.")
    ap.add_argument("--mode", choices=["auto", "dense", "sparse"], default="auto", help="Input format (default: auto).")
    ap.add_argument("--num-variants", type=int, default=None, help="Number of variants (for sparse; overrides inference).")
    ap.add_argument("--to-npz", type=str, default=None, help="Write parsed data to NPZ in its native representation.")
    ap.add_argument("--to-dense-npz", type=str, default=None, help="If input is sparse, convert to dense and save here.")
    ap.add_argument("--print-first", type=int, default=0, help="Print first N reads (ids and first 80 alleles).")
    args = ap.parse_args()

    mode = args.mode
    if mode == "auto":
        mode = sniff_mode(args.input)

    if mode == "dense":
        dr = parse_dense_tsv(args.input)
        print(summarize_dense(dr))

        if args.print_first > 0 and len(dr.read_ids) > 0:
            n = min(args.print_first, len(dr.read_ids))
            print(f"First {n} reads (id, hap_truth, alleles[0:80]):")
            for i in range(n):
                s = "".join("-" if x < 0 else ("1" if x == 1 else "0") for x in dr.alleles[i, :80])
                print(f"  {dr.read_ids[i]}\t{dr.hap_truth[i]}\t{s}")

        if args.to_npz:
            save_dense_npz(dr, args.to_npz)
            print(f"Saved dense NPZ to: {args.to_npz}")

        if args.to_dense_npz:
            # Already dense; same as to_npz but to a different path
            save_dense_npz(dr, args.to_dense_npz)
            print(f"Saved dense NPZ to: {args.to_dense_npz}")

    elif mode == "sparse":
        sr = parse_sparse_tsv(args.input, num_variants=args.num_variants)
        print(summarize_sparse(sr))

        if args.print_first > 0 and len(sr.read_ids) > 0:
            n = min(args.print_first, len(sr.read_ids))
            print(f"First {n} reads (id, hap_truth, first up to 10 (pos,allele)):")
            for i in range(n):
                s_idx = sr.read_ptr[i]
                e_idx = sr.read_ptr[i + 1]
                pos = sr.positions[s_idx:e_idx]
                val = sr.alleles[s_idx:e_idx]
                pairs = []
                for j in range(min(10, pos.size)):
                    a = val[j]
                    ch = "-" if a < 0 else ("1" if a == 1 else "0")
                    pairs.append(f"({pos[j]},{ch})")
                print(f"  {sr.read_ids[i]}\t{sr.hap_truth[i]}\t" + " ".join(pairs))

        if args.to_npz:
            save_sparse_npz(sr, args.to_npz)
            print(f"Saved sparse NPZ to: {args.to_npz}")

        if args.to_dense_npz:
            dr = sparse_to_dense(sr, fill_value=-1)
            save_dense_npz(dr, args.to_dense_npz)
            print(f"Saved dense NPZ (from sparse) to: {args.to_dense_npz}")

    else:
        raise ValueError(f"Unknown mode: {mode}")


if __name__ == "__main__":
    main()